Instrucciones {
	0x0: tipo O -> instruccion las cuales generan una operacion aritmetica => OR R3, R2, R1
	0x1: LD -> carga en un registro una posicion de memoria => 
	0x2: SD -> guarda en la memoria el valor de un registro => 
	0x3: RET -> retorna a la direccion de memoria antes de saltar => RET
	0x4: ADDC -> suma un registro y una constante y lo guarda en un registro => ADDC R4, R4, 1
	0x5: JMP -> salto incondicional => JMP 1000 # salta a la linea 1000
	0x6: JEQ -> compara dos registros y si son iguales salta => JEQ R1, ZERO, 23 # salta a la linea 23
	0x7: JNE -> no son iguales => JNE R2, R5, 12
	0x8: JLT -> menor que
	0x9: JGT -> mayor que
	0xA: JAL -> salta incondicionalmente y guarda la posicion del PC => JAL 12
	0xB: EXIT -> termina el programa
}

Set de instrucciones {
	TIPO O (operation) {
		opcode = 4 bits 
		r1 = 3 bits 
		r2 = 3 bits 
		rd = 3 bits 
		funct = 3 bits 
	}

	Tipo C (const) {
		opcode = 4 bits 
		r1 = 3 bits 
		rd = 3 bits 
		const = 6 bits 
	}

	Tipo M (memory) {
		opcode = 4 bits
		r1 = 3 bits 
		address = 9 bits

		r1 = memory[address]
	}

	Tipo J (jump) {
		opcode = 4 bits
		address = 12 bits 
	}
}

Regs {
	000: ZERO || R0
	001: R1
	010: R2
	011: R3
	100: R4
	101: R5
	110: R6
	111: R7
}

Funct {
	000: add
	001: sub
	010: mul
	011: div
	100: and
	101: or
	110: xor
	111: nand
}

JumpFunct {
	00: JEQ
	01: JNE
	10: JLT
	11: JGT
}


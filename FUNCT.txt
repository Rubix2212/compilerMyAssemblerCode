Set de instrucciones {
	Tipo o (Operation) {
		opcode = 4 bits
		r1 = 2 bits
		r2 = 2 bits
	}
}

Registros {
	A = 00
	B = 01
	C = 10
	D = 11
}

Instrucciones {
  0x00 =>  NOP  -> nada
	0x0  =>  ADD  -> sumas dos registros y los concatena -> ADD A, B # a += b
	0x1  =>  SUB  -> resta dos registros y los concatena -> SUB A, C # a -= c
	0x2  =>  AND  -> hace un and a dos registros y los concatena -> AND A, C # a &= c
	0x3  =>  OR   -> hace un or a dos registros y los concatena -> AND A, C # a |= c
	0x4  =>  GOTO -> salta incondicionalmente -> GOTO 11 (no puede sobrepasar las 15 lineas)
	0x5  =>  CMP  -> compara dos registros (se usa para los jumps) -> CMP A, B # guarda el resultado en un registro llamado T (Temporary)
	0x6  =>  JEQ  -> si CMP fue 00 (iguales) salta -> JEQ 11 (no puede sobrepasar las 15 lineas)
	0x7  =>  JNE  -> si CMP fue 01 (no iguales) salta -> JNE 6 (no puede sobrepasar las 15 lineas)
	0x8  =>  JLT  -> si CMP fue 10 (menor que) salta -> JLT 0xC (no puede sobrepasar las 15 lineas)
	0x9  =>  JGT  -> si CMP fue 11 (mayor que) salta -> JGT 0xF (no puede sobrepasar las 15 lineas
	0xA  =>  RET  -> retorna a la direccion antes de saltar -> RET # la direccion se guarda en un registro llamado TJA (TemporaryJumpAddress) 
	0xB  =>  SD   -> guarda en la memoria el valor de un registro -> SD A, B # memory[A] = B
	0xC  =>  LD   -> carga en un registro el valor de la memoria -> LD A, D # A = memory[D]
	0xD  =>  LI   -> carga en un registro un valor -> LI A, 2 (no puede sobrepasar 4)
	0xE	 =>  MV   -> copia el valor de un registro a otro -> MV A, B # A = B
	0xF  =>  
}

JUMP CONTROL {
	000: no-jump,
	001: JEQ,
	010: JNE,
	011: JLT,
	100: JGL,
	101: RET,
	110: CMP,
	111: no-jump
}